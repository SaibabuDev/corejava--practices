package arrays;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;


public class TestClass {
    private static char c;

	public static void main(String[] args) throws IOException {
       /* BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
     //   PrintWriter wr = new PrintWriter(System.out);
        int N = Integer.parseInt(br.readLine().trim());
        String S = br.readLine();
        System.out.println(CountPS(S.toCharArray(),S.length()))
       // wr.close();
        br.close();*/
        String str = "ababa";
        allPalPartitions(str);
    }
          static void allPalPartitions(String input)  
    { 
        int n = input.length(); 
  
        // To Store all palindromic partitions 
        ArrayList<ArrayList<String>> allPart = new ArrayList<>(); 
  
        // To store current palindromic partition 
        Deque<String> currPart = new LinkedList<String>(); 
  
        // Call recursive function to generate  
        // all partiions and store in allPart 
        allPalPartitonsUtil(allPart, currPart, 0, n, input); 
  
        // Print all partitions generated by above call 
        for (int i = 0; i < allPart.size(); i++)  
        { 
            for (int j = 0; j < allPart.get(i).size(); j++) 
            { 
                System.out.print(allPart.get(i).get(j) + " "); 
            } 
            System.out.println(); 
        } 
  
}

 private static void allPalPartitonsUtil(ArrayList<ArrayList<String>> allPart,  
            Deque<String> currPart, int start, int n, String input) 
    { 
        // If 'start' has reached len 
        if (start >= n)  
        { 
            allPart.add(new ArrayList<>(currPart)); 
            return; 
        } 
  
        // Pick all possible ending points for substrings 
        for (int i = start; i < n; i++)  
        { 
              
            // If substring str[start..i] is palindrome 
            if (isPalindrome(input, start, i)) 
            { 
                  
                // Add the substring to result 
                currPart.addLast(input.substring(start, i + 1)); 
                 System.out.println(" "+currPart);
                // Recur for remaining remaining substring 
                allPalPartitonsUtil(allPart, currPart, i + 1, n, input); 
                System.out.println(" "+allPart);
                // Remove substring str[start..i] from current 
                // partition 
                currPart.removeLast(); 
            } 
        } 
    } 
    
     private static boolean isPalindrome(String input,  
                                    int start, int i) 
    { 
        while (start < i)  
        { 
         
			if (input.charAt(start++) != input.charAt(i--)) 
            
                return false; 
        } 
        return true; 
    } 
}